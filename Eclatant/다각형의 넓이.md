# Front-end Level 2

## 다각형의 넓이

### 다각형의 넓이

#### 1. 반지름이 10cm인 원 넓이를 출력한다.

```javascript
console.log(10 * 10 * Math.PI);
```

#### 2. 밑변 10cm, 높이15cm인 사각형의 넓이를 출력한다.

```javascript
console.log(10 * 15);
```

#### 3. 밑변 10cm, 윗변 5cm, 높이가 12cm인 사다리꼴의 넓이를 출력한다.

```javascript
console.log((10 + 5) * 12 / 2);
```



### MDN을 활용한 학습법

- Syntax(문법)에서 파라미터와 반환값에 대한 설명이외에, 자세한 설명이 나온다.
- Examples를 통해서 API의 사용법을 잘 따라하면서 학습하는 것이 좋다.
- 또한 Browser compatibility 항목을 항상 보는 습관을 들여야 한다.




---

### 다각형을 계산하는 함수

#### 1. 다각형 계산

다각형의 넓이를 함수를 호출해서 실행하도록 하자. 하나의 소스코드에 3개의 함수를 정의하고, 3개의 함수를 호출해서 그 결과를 한줄씩 출력한다. 사다리꼴의 넓이를 구하기 위해서는 3개의 인자를 받아야한다. 만약 2개의 인자만 받으면 '3개의 인자가 필요합니다' 라는 메시지를 노출하자.

```javascript
function circle(radius) {
  if (arguments.length !== 1) {
    console.log("1개의 인자가 필요합니다.");
    return null;
  }

  var result = Math.pow(radius, 2) * Math.PI;

  return result;
}

function rectangle(base, height) {
  if (arguments.length !== 2) {
    console.log("2개의 인자가 필요합니다.");
    return null;
  }

  var result = base * height;

  return result;
}

function trapezoid(base, upperSide, height) {
  if (arguments.length !== 3) {
    console.log("3개의 인자가 필요합니다.");
    return null;
  }

  var result = base * upperSide * height / 2;

  return result;
}

// arguments 대신 Rest Parameter를 사용한 이유는 두 가지 이점이 있어서이다.
// arguments와 달리 완전한 배열을 받을 수 있고, arguments로는 일부 인수들만 묶을 수 없기 때문이다.

function polygon(type, ...numbers) {
  switch (type) {
    case "원":
      if (numbers.length !== 1) {
        console.log("1개의 인자가 필요합니다.");
        return null;
      }

      return Math.pow(numbers[0], 2) * Math.PI;
    case "사각형":
      if (numbers.length !== 2) {
        console.log("2개의 인자가 필요합니다.");
        return null;
      }

      return numbers[0] * numbers[1];
    case "사다리꼴":
      if (numbers.length !== 3) {
        console.log("3개의 인자가 필요합니다.");
        return null;
      }

      return numbers[0] * numbers[1] * numbers[2] / 2;
  }
}
```



#### 2. 추가요구사항
- ##### 함수표현식이라는 것도 있다. 같은 함수라고 보면 된다. 함수 문법이 어떻게 되어 있는지 알아보자.
  - [함수 표현식 vs 함수 선언식](https://joshua1988.github.io/web-development/javascript/function-expressions-vs-declarations/)

  - [Function Declarations(함수선언) vs Function Expressions(함수표현)](http://insanehong.kr/post/javascript-function/)

  - 함수 선언식

    - function 함수명() {}
      - 실행가능한 코드블럭이 아니며 함수의 정의를 나타내는 문장으로 해석되며 따라서 코드해석에 따른 수행결과가 존재하지 않는다는 것을 의미한다. 함수 선언문이 `Statement` 라고 하는 말은 정의에서 밝힌것 처럼 코드블럭 자체는 **실행가능 코드가 아니라는 것**이다. 즉 해당 코드블럭을 **콘솔에서 실행하여도 어떠한 결과도 return 되지 않는다**. 그러한 이유로 함수선언문을 Class와 동일한 개념으로 이해해도 무방하다. statement 는 console 에서 실행을 시켜도 아무런 결과를 반환하지 않는다.

  - 함수 표현식

    - const func = `function() {}` `||` `function 함수명() {}`
      - 함수표현은 `Function Literal` 이다 이는 실행 가능한 코드로 해석 되어지거나 변수나 데이터구조에 할당되어지고 있음을 의미한다. 즉 해당 코드블럭이 실행코드로서 해석되어지며 동시에 코드실행에 따른 결과값을 가지거나 특정 변수에 할당된 값으로 존재한다. 이처럼 함수표현은 함수리터럴로 특정변수에 할당되거나 즉시 실행가능한 코드 블럭으로서 존재하는 함수를 의미하는 것이다. 함수표현이 실행코드로서 해석되기 위해서는 ()를 이용하여 함수를 감싸 주어야 한다. 이를 `자기호출함수(self invoking function)` 라고도 한다. 자기호출함수는 **재귀함수와는 다른 개념**이다. 재귀함수는 함수 안에서 자신을 호출하는 형식이지만 자기호출함수는 **해석과 동시에 실행되는 코드블럭**을 말한다.
      - 위 코드에서`named function expression`는 매우 특이하다. foo 라는 변수에 이름있는 함수를 할당하고 있다. 흔히 알고 있는 함수리터럴과는 좀 거리가 있다. 하지만 이 `named function expression`에는 한가지 특징이 있다. 바로 해당 함수의 이름은 함수밖에서는 사용할수 없다는 것이다. 즉 재귀호출에서 사용가능하도록 해준다.

  - 함수 선언식과 표현식의 차이점

    - 함수 선언식은 호이스팅에 영향을 받지만, 함수 표현식은 호이스팅에 영향을 받지 않는다.
      - 인터프린터가 자바스크립트 코드를 해석함에 있어서 **Global 영역의 선언된 코드블럭을 최상의 Scope로 끌어올리는 것**을 호이스팅이라 한다. 즉 Global 영역에 선언된 변수 또는 함수는 자바사크립트 엔진이 가장 먼저 해석하게 된다. 단 할당구문은 런타임과정 이루어지기 때문에 hosting 되지 않는다. 이 정의가 다소 어려울수도 있다. 하지만 단순하게 **선언문은 항시 자바스크립트 엔진 구동시 가장 최우선으로 해석**한다고 이해하면 쉬울 것이다. 이 hoisting에서 중요한 부분은 **statement 는 hoisting 되지만 할당은 hoisting 되지 않는 다는 것**이다. 즉 {} 안의 내용은 포함하지만 = 연사자를 사용한 값은 hoisting 되지 않는다.

  - 함수 표현식의 장점

    - ‘함수 표현식이 호이스팅에 영향을 받지 않는다’ 는 특징 이외에도 함수 선언식보다 유용하게 쓰이는 경우는 다음과 같다.

      - 클로져로 사용

        - ```javascript
          function tabsHandler(index) {
              return function tabClickEvent(event) {
                  console.log(index);
              };
          }

          for (i = 0; i < tabs.length; i += 1) {
              tabs[i].onclick = tabsHandler(i);
          }
          ```

      - 콜백으로 사용 (다른 함수의 인자로 넘길 수 있음)

        - ```javascript
          var arr = ["a", "b", "c"];

          arr.forEach(function () {
            // ...
          });
          ```

- ##### arrow함수는 무엇인가? 어떤 문법으로 되어 있는가? 브라우저 지원범위는 얼마큼인가?

  - [Arrow functions MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

    - Two factors influenced the introduction of arrow functions: shorter functions and non-binding of `this`.

    - ```javascript
      var arr = [5, 6, 13, 0, 1, 18, 23];

      var sum = arr.reduce((a, b) => a + b); // 66
      ```

  - [ES6 In Depth: 화살표 함수(Arrow functions)](http://hacks.mozilla.or.kr/2015/09/es6-in-depth-arrow-functions/)

    - 통상적인 `function` 함수와 화살표 함수 사이에는 약간의 차이점이 있습니다. **화살표 함수는 자기 고유의 this 값을 갖지 않습니다.** 화살표 함수 안의 `this` 값은 언제나 화살표 함수를 감싸는 외부 스코프(scope)에서 계승 받습니다.

  - [ECMAScript 6 - 화살표 함수와 메소드 정의](http://webframeworks.kr/tutorials/translate/arrow-function/)

  - 함수 표현식을 짧게 쓸 수 있게 해주며, this 바인딩을 해주어 동작이 보다 예상가능하도록 해준다

  - 브라우저 지원범위

    - [Can I Use](https://caniuse.com/#search=arrow)
      - IE Not Supported


---

### 파라미터를 체크하는 다각형의 넓이 함수

```javascript
// calculateCircle(10) 인경우 정상적인 결과를 출력.

// calculateCircle("10") 인경우
// > "숫자형타입만 계산이 가능합니다."

// calculateCircle() 인경우
// > "최소 한가지 값이 필요합니다"

// calculateCircle(-1) 인경우
// > "반지름은 0보다 커야 합니다"

function checkArgTypeofNumber(arg, predictArgNumber) {
  for (var i = 0; i < predictArgNumber; i += 1) {
    if (typeof arg[i] !== "number") {
      console.log("숫자형 타입만 계산이 가능합니다!");
      return true;
    }
  }

  return false;
}

function circle(radius) {
  if (arguments.length !== 1) {
    console.log("1개의 인자가 필요합니다.");
    return null;
  }

  if (checkArgTypeofNumber(arguments, 1)) {
    return null;
  }

  if (radius <= 0) {
    console.log("반지름은 0보다 커야 합니다.");
    return null;
  }

  var result = Math.pow(radius, 2) * Math.PI;

  return result;
}

function rectangle(base, height) {
  if (arguments.length !== 2) {
    console.log("2개의 인자가 필요합니다.");
    return null;
  }

  if (checkArgTypeofNumber(arguments, 2)) {
    return null;
  }

  if (base <= 0) {
    console.log("밑변은 0보다 커야 합니다.");
    return null;
  }

  if (height <= 0) {
    console.log("높이는 0보다 커야 합니다.");
    return null;
  }

  var result = base * height;

  return result;
}

function trapezoid(base, upperSide, height) {
  if (arguments.length !== 3) {
    console.log("3개의 인자가 필요합니다.");
    return null;
  }

  if (checkArgTypeofNumber(arguments, 3)) {
    console.log("숫자형 타입만 계산이 가능합니다.");
    return null;
  }

  if (base <= 0) {
    console.log("밑변은 0보다 커야 합니다.");
    return null;
  }

  if (upperSide <= 0) {
    console.log("윗변은 0보다 커야 합니다.");
    return null;
  }

  if (height <= 0) {
    console.log("높이는 0보다 커야 합니다.");
    return null;
  }

  var result = base * upperSide * height / 2;

  return result;
}
```

Javascript의 타입에 최근에 Symbol이 추가되었다. [Symbol MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)



---
### 만능함수와 디버깅

#### getArea 함수를 통해 모든 넓이 값을 얻을 수 있다.
```javascript
// getArea('circle', 10);
// > 원의 넓이 값출력

// getArea('rect', 10,15);
// > 사각형의 넓이값출력

// getArea('trapezoid', 10,15,12);
// > 사다리꼴의 넓이값출력

// getArea('circle', 1, 100);
// > 반지름이 1부터 100까지 1씩 증가하면서, 100개의 원의 넓이의 결과값을 출력.

function checkArgTypeofNumber(arg, predictArgNumber) {
  for (var i = 0; i < predictArgNumber; i += 1) {
    if (typeof arg[i] !== "number") {
      console.log("숫자형 타입만 계산이 가능합니다!");
      return true;
    }
  }

  return false;
}

function circle(numArr) {
  if (numArr.length !== 1) {
    console.log("1개의 인자가 필요합니다.");
    return null;
  }

  if (checkArgTypeofNumber(numArr, 1)) {
    return null;
  }

  if (numArr[0] <= 0) {
    console.log("반지름은 0보다 커야 합니다.");
    return null;
  }

  var result = Math.pow(numArr[0], 2) * Math.PI;

  return result;
}

function rect(numArr) {
  if (numArr.length !== 2) {
    console.log("2개의 인자가 필요합니다.");
    return null;
  }

  if (checkArgTypeofNumber(numArr, 2)) {
    return null;
  }

  if (numArr[0] <= 0) {
    console.log("밑변은 0보다 커야 합니다.");
    return null;
  }

  if (numArr[1] <= 0) {
    console.log("높이는 0보다 커야 합니다.");
    return null;
  }

  var result = numArr[0] * numArr[1];

  return result;
}

function trapezoid(numArr) {
  if (numArr.length !== 3) {
    console.log("3개의 인자가 필요합니다.");
    return null;
  }

  if (checkArgTypeofNumber(numArr, 3)) {
    console.log("숫자형 타입만 계산이 가능합니다.");
    return null;
  }

  if (numArr[0] <= 0) {
    console.log("밑변은 0보다 커야 합니다.");
    return null;
  }

  if (numArr[1] <= 0) {
    console.log("윗변은 0보다 커야 합니다.");
    return null;
  }

  if (numArr[2] <= 0) {
    console.log("높이는 0보다 커야 합니다.");
    return null;
  }

  var result = numArr[0] * numArr[1] * numArr[2] / 2;

  return result;
}

// Array.prototype 사용하기 : http://www.bsidesoft.com/?p=323
// arguments는 완전한 배열이 아니므로 slice를 하려면 아래처럼 코드를 써야 한다
function getArea(calculateCase) {
  var arg = Array.prototype.slice.call(arguments, 1);

  switch (calculateCase) {
    case "circle":
      console.log(circle(arg));
      break;
    case "rect":
      console.log(rect(arg));
      break;
    case "trapezoid":
      console.log(trapezoid(arg));
      break;
  }
}
```



---
### 배열을 이용한 로깅

```javascript
// getCircle(), getArea() 등 실제 넓이 계산이 일어나는 경우 그 횟수를 출력하자.

// getCircle()
// > 계산이 1번 일어났습니다.

// getCircle()
// > 계산이 2번 일어났습니다.

// getArea('circle',2)
// > 계산이 3번 일어났습니다.

// getArea('rect',2,3)
// > 계산이 4번 일어났습니다.

// getReport() //계산수행순서를 저장했다가 자유롭게 그 내역을 출력해보자. 배열을 사용할 수 있다.
// > 계산수행순서 : circle, circle, circle, rect

function checkArgTypeofNumber(arg, predictArgNumber) {
  for (var i = 0; i < predictArgNumber; i += 1) {
    if (typeof arg[i] !== "number") {
      console.log("숫자형 타입만 계산이 가능합니다!");
      return true;
    }
  }

  return false;
}

function getCircle(numArr) {
  if (numArr.length !== 1) {
    console.log("1개의 인자가 필요합니다.");
    return null;
  }

  if (checkArgTypeofNumber(numArr, 1)) {
    return null;
  }

  if (numArr[0] <= 0) {
    console.log("반지름은 0보다 커야 합니다.");
    return null;
  }

  var result = Math.pow(numArr[0], 2) * Math.PI;

  calculateCount.circle += 1;
  calculateCount.commandOrder.push("circle");

  var count = calculateCount.circle;
  console.log("계산이 " + count + "번 일어났습니다.");

  return result;
}

function getRect(numArr) {
  if (numArr.length !== 2) {
    console.log("2개의 인자가 필요합니다.");
    return null;
  }

  if (checkArgTypeofNumber(numArr, 2)) {
    return null;
  }

  if (numArr[0] <= 0) {
    console.log("밑변은 0보다 커야 합니다.");
    return null;
  }

  if (numArr[1] <= 0) {
    console.log("높이는 0보다 커야 합니다.");
    return null;
  }

  var result = numArr[0] * numArr[1];

  calculateCount.rect += 1;
  calculateCount.commandOrder.push("rect");

  var count = calculateCount.rect;
  console.log("계산이 " + count + "번 일어났습니다.");

  return result;
}

function getTrapezoid(numArr) {
  if (numArr.length !== 3) {
    console.log("3개의 인자가 필요합니다.");
    return null;
  }

  if (checkArgTypeofNumber(numArr, 3)) {
    console.log("숫자형 타입만 계산이 가능합니다.");
    return null;
  }

  if (numArr[0] <= 0) {
    console.log("밑변은 0보다 커야 합니다.");
    return null;
  }

  if (numArr[1] <= 0) {
    console.log("윗변은 0보다 커야 합니다.");
    return null;
  }

  if (numArr[2] <= 0) {
    console.log("높이는 0보다 커야 합니다.");
    return null;
  }

  var result = numArr[0] * numArr[1] * numArr[2] / 2;

  calculateCount.trapezoid += 1;
  calculateCount.commandOrder.push("trapezoid");

  var count = calculateCount.trapezoid;
  console.log("계산이 " + count + "번 일어났습니다.");

  return result;
}

// Array.prototype 사용하기 : http://www.bsidesoft.com/?p=323
// arguments는 완전한 배열이 아니므로 slice를 하려면 아래처럼 코드를 써야 한다
function getArea(calculateCase) {
  var arg = Array.prototype.slice.call(arguments, 1);

  switch (calculateCase) {
    case "circle":
      console.log(getCircle(arg));
      break;
    case "rect":
      console.log(getRect(arg));
      break;
    case "trapezoid":
      console.log(getTrapezoid(arg));
      break;
  }
}

var calculateCount = {
  circle: 0,
  rect: 0,
  trapezoid: 0,
  commandOrder: []
};

function getReport() {
  console.log(calculateCount.commandOrder.join(", "));
}
```



#### Array Method forEach
- [Array Methods MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Methods)

- arr.forEach(callback[, thisArg])

  - callback에 들어가는 함수는 currentValue, index, array 세 인수를 넘겨받는다

  - thisArg는 callback 실행 시의 this를 인수로 넘겨줄 수 있다

  - ```javascript
    [1, 2, 3, 4, 5].forEach((v, i, o) => {
      console.log(v); // 1 -> 2 -> 3 -> 4 -> 5
      console.log(i); // 0 -> 1 -> 2 -> 3 -> 4
      console.log(o); // [1, 2, 3, 4, 5] -> ... -> [1, 2, 3, 4, 5]
    });
    ```
